; -*- Mode: Lisp; Package: INSPECTOR; -*-;;	Change History (most recent first):;;  2 6/2/97   akh  splitter has cursor;;  1 2/9/97   alice hartley new;;  2 10/17/95 akh  merge patches;;  10 5/26/95 akh  edit definition menu item works if encapsulated fn;;  9 5/22/95  akh  remember restart-frame inspectors in backtrace so can close when backtrace closes;;  7 5/7/95   slh  balloon help mods.;;  5 4/24/95  akh  restart-frame and return-from-frame get correct saved registers;;  4 4/11/95  akh  edit value button disabled initially;;  3 4/10/95  akh  make edit-value button disabled when appropriate;;  2 4/7/95   akh  crescent on pull-down-menu;;  4 3/20/95  akh  move method after class definition;;  3 3/20/95  akh  editing-dialogs-p method for backtrace-window;;  2 3/2/95   akh  move line between panes so each contains full lines;;  2 2/3/95   slh  copyright thang;;  (do not edit before this line!!); Copyright 1985-1988 Coral Software Corp.; Copyright 1989-1994 Apple Computer, Inc.; Copyright 1995-2000 Digitool, Inc.;;;;;;;;;;; Backtrace for new inspector;;;;;;;;;;;;; Change History;; don't say moveto :long;; ;; "Geneva" 10 => "Courier" 12 - somewhat less ugly on OSX;; ------- 5.1 final;; dragging-pane-splitter draws gray if window not active;; -------- 5.1b2 ;; backtrace-command-pane is theme-background-view;; dragging-pane-splitter gets gray background;; -------- 5.1b1;; 10/27/97 akh method (setf line-n) (value (i stack-frame-inspector) n) - use *saved-register-count* vs 5;; 04/22/97 akh  pane-splitter gets a cursor;; 07/17/96 bill  Add support for *backtrace-internal-functions*.;;                Switched on or off by *backtrace-hide-internal-functions-p*.;;                error-frame-n instance samples *break-condition*.;;                Command pane offers to inspect saved break condition.;; 06/25/96 bill  If *show-backtrace-frame-addresses* is true, stack-inspector will display;;                the sp/vsp instead of the frame index.;; 04/12/96 bill  (method initialize-instance (stack-inspector)) ensures that the frames;;                are valid by coercing each frame to (child-frame (parent-frame frame sg) sg).;; -------------- MCL-PPC 3.9;; 03/21/96 gb    method line-n ((i stack-frame-inspector) n): access ccl::*saved-register-numbers* backwards.;;                Or maybe forwards.;; 03/14/96 bill  update backtrace-restart-frame & backtrace-return-from-frame for the new order.;; 02/22/96 bill  Comment out error-frame-index and error-frame-child; they're;;                no longer used.;;                Fix some PPC fenceposts in (method initialize-instance (error-frame)).;; 02/14/96 bill  remove sgbuf.csbuf from merge-saved-vars for ppc-target.;; 12/20/95 bill  don't require inspector-package;; 12/19/95 bill  (%cons-saved-register-vector) instead of explicit dsave0, etc.;;  4/28/95 slh   require inspector-package to make everyone happy;; -------------- 3.0d16;; 04/13/93 bill  pass stack group to set-nth-value-in-frame;; -------------- 2.1d5;; 04/10/93 alice dragging pane splitter erases before draw, repair some mis-merge;; 03/10/93 alice pane-splitter-outline-position is a point today - UI makeover;; 03/12/93 bill  support segmented stacks;; -------------  2.0;; 11/12/91 bill  Add help specs, add "..." to menu items.;; 10/??/91 alice window-can-do-operation pass item to view-can-undo-p;; 10/04/91 bill no more BACKTRACE;;----------- 2.0b3;; 08/22/91 bill  in (method line-n (stack-inspector t)) - value is;;                unselectable if lfun is unknown;; 07/26/91 alice window-can-do-operation;; 07/03/91 alice adapt for extra thing in *backtrace-dialogs* entry;; 07/09/91 bill add "ccl::" package prefix for unexported symbols;;               make choose-restart work.;;               Alice's upload will fix this by making the restarts window truly non-modal.;; 05/03/91 bill fix LOCAL.  (method (setf line-n) (t stack-frame-inspector t));;               xSAVEn is the arg type, not the label for the line.;; 01/16/91 bill pane-splitter-outline-position;; 01/08/91 bill convert to new traps;; 12/13/90 bill BACKTRACE no longer enters TMON or MacsBug;; 12/12/90 bill Mod *backtrace-sizes* so that entire window is visible on a Classic Mac;; 11/05/90 bill "Restarts" command.  Sticky window-position and size;; 10/24/90 bill changed some defmethod's to defun's;; 10/02/90 bill split-pane;; 09/25/90 bill speed up and reduce consing for backtrace of stack-overflow;; 09/24/90 bill integer-digits vice log;;;;;;;;;(in-package :inspector);;;;;;;;;;; an ERROR-FRAME stores the stack addresses that the backtrace window displays;;;; set to list of function you don't want to see;; Functions can be symbols, nil for kernel, or #'functions(defparameter *backtrace-internal-functions*    (list :kernel))(defvar *backtrace-hide-internal-functions-p* t)(defclass error-frame ()  ((addresses :accessor addresses)   (restart-info :accessor restart-info)   (sampling-period :initarg :sampling-period :initform 32 :reader sampling-period)   (stack-start :initarg :stack-start :initform (ccl::%get-frame-ptr) :reader stack-start)   (stack-end :initarg :stack-end :initform (ccl::last-frame-ptr) :reader stack-end)   (stack-group :initarg :stack-group :initform ccl::*current-stack-group* :reader stack-group)   (frame-count :accessor frame-count)   (ignored-functions :accessor ignored-functions                      :initform (and *backtrace-hide-internal-functions-p*                                     *backtrace-internal-functions*))   (break-condition :accessor break-condition                    :initform ccl::*break-condition*))); This is set up to access the result of; (multiple-value-call #'vector (ccl::parent-frame-saved-vars ...))(ccl::def-accessors svref  %sv.frame  %sv.last-catch  %sv.srv)#|(defmethod initialize-instance ((f error-frame) &key)  (call-next-method)  (let* ((count 0)         (p (stack-start f))         (q (stack-end f))         (period (sampling-period f))	 (sg (stack-group f))         (addresses (make-array (1+ (ceiling (ash (- p q) -1) period)))))    (setf (addresses f) addresses          (svref addresses 0) (ccl::child-frame p sg)          (svref addresses 1) p)    (do* ((p (stack-start f) (ccl::parent-frame p sg))          (cnt (1+ period))          (idx 1))         ((or (null p) (< p q)))      (when (eql 0 (decf cnt))        (setq cnt period)        (setf (svref addresses (incf idx)) p))      (incf count))    (setf (frame-count f) count)))|#(defun ignore-function-in-backtrace? (error-frame function)  (loop for ignored-fn in (ignored-functions error-frame)        when (and (null function) (eq ignored-fn :kernel)) return t        when (and (symbolp ignored-fn) (eq (function-name function) ignored-fn)) return t        when (eq ignored-fn function) return t        finally (return nil))); use parent-frame-saved-vars to cons a vector for each element of ADDRESSES(defmethod initialize-instance ((f error-frame) &key)  (call-next-method)  (initialize-addresses f))(defmethod initialize-addresses ((f error-frame))   (with-cursor *watch-cursor*     (#_showcursor)     (let ((end (stack-end f)))       (flet ((skip-to-important-frame (frame sg)                (loop for this? = (or (eq frame end)                                      (not (ignore-function-in-backtrace?                                            f                                            (ccl::cfp-lfun frame sg))))                      until this?                      do (setf frame (ccl::parent-frame frame sg))                      finally (return frame))))         (setf (slot-value f 'stack-start)               (skip-to-important-frame (stack-start f) (stack-group f)))))      (let* ((count 0)             (sg (stack-group f))             (p (stack-start f))             (p-child (ccl::child-frame p sg))             (q (stack-end f))             (period (sampling-period f))             (addresses nil)             (last-frame nil))        (multiple-value-bind (frame catch srv)                             (ccl::last-catch-since-saved-vars p-child sg)          (loop            (if (null frame) (error "Can't find saved vars info"))            (if (eq frame p-child) (return))            (multiple-value-setq (frame catch srv)              (ccl::parent-frame-saved-vars sg frame catch srv srv)))          (push (vector p-child catch (ccl::copy-srv srv))                addresses)          (setq last-frame frame)          (multiple-value-setq (frame catch srv)            (ccl::parent-frame-saved-vars sg frame catch srv srv))          (unless (eq frame p) (error "(~s (~s ~d)) <> ~d"                                      'ccl::parent-frame 'ccl::child-frame p p))          (push (vector frame catch (ccl::copy-srv srv))                addresses)          (flet ((done-p ()                     (or (null frame) (eql last-frame q))))             (block loop                (do* ((cnt (1+ period)))                     ((done-p))                  (loop while (ignore-function-in-backtrace?                             f (ccl::cfp-lfun frame sg))                      do                       (setq last-frame frame)                      (multiple-value-setq (frame catch srv)                        (ccl::parent-frame-saved-vars sg frame catch srv srv))                      (when (done-p) (return-from loop)))                  (when (eql 0 (decf cnt))                    (setq cnt period)                    (push (vector frame catch (ccl::copy-srv srv))                          addresses))                  (setq last-frame frame)                  (multiple-value-setq (frame catch srv)                    (ccl::parent-frame-saved-vars sg frame catch srv srv))                  (incf count))))          (setf (frame-count f) count                (addresses f) (list-to-vector (nreverse addresses)))))))(defun error-frame-n (error-frame n)  (let* ((addresses (addresses error-frame))         (period (sampling-period error-frame))	 (sg (stack-group error-frame))         p child)    (flet ((skipping-uninteresting-parent-frames (child)            (loop while (ignore-function-in-backtrace?                          error-frame (ccl::cfp-lfun (ccl::parent-frame child sg) sg))                  do (setq child (ccl::parent-frame child sg))                  finally (return child))))      (unless (< -1 n (frame-count error-frame))        (setq n (require-type n `(integer 0 ,(1- (frame-count error-frame))))))      (if (eql 0 n)        (setq child (%sv.frame (svref addresses 0))              p (%sv.frame (svref addresses 1)))        (multiple-value-bind (idx offset) (floor (1- n) period)          (setq child (skipping-uninteresting-parent-frames                        (%sv.frame (svref addresses (1+ idx)))))          (dotimes (i offset)            (declare (fixnum i))            (setq child (skipping-uninteresting-parent-frames                          (ccl::parent-frame child sg))))          (setq p (ccl::parent-frame child sg))))      (values p child))))(defmethod error-frame-address-n ((f error-frame) n)  (multiple-value-bind (p child) (error-frame-n f n)    (multiple-value-bind (lfun pc) (ccl::cfp-lfun p (stack-group f) child)      (values p lfun pc child)))); Returns 6 values:; p lfun pc child last-catch srv; Where the last-catch & register values are those for the CHILD's frame; (the ones we need to look at to display values for frame P).(defmethod error-frame-regs-n ((f error-frame) n)  (let* ((addresses (addresses f))         (period (sampling-period f))         (sg (stack-group f))         p child last-catch srv)    (unless (< -1 n (frame-count f))      (setq n (require-type n `(integer 0 ,(1- (frame-count f))))))    (if (eql 0 n)      (let ((child-sv (svref addresses 0)))        (setq child (%sv.frame child-sv)              last-catch (%sv.last-catch child-sv)              srv (ccl::copy-srv (%sv.srv child-sv))))      (multiple-value-bind (idx offset) (floor (1- n) period)        (let ((child-sv (svref addresses (1+ idx))))          (setq child (%sv.frame child-sv)                last-catch (%sv.last-catch child-sv)                srv (ccl::copy-srv (%sv.srv child-sv))))        (flet ((maybe-ignore ()                 (loop while (ignore-function-in-backtrace?                             f                            (ccl::cfp-lfun (ccl::parent-frame child sg) sg))                      do (multiple-value-setq (child last-catch srv)                          (ccl::parent-frame-saved-vars sg child last-catch srv srv)))))         (maybe-ignore)           (dotimes (i offset)             (declare (fixnum i))             (multiple-value-setq (child last-catch srv)               (ccl::parent-frame-saved-vars sg child last-catch srv srv))            (maybe-ignore)            ))))    (unless child (error "shouldn't happen"))    (setq p (ccl::parent-frame child sg))    (multiple-value-bind (lfun pc) (ccl::cfp-lfun p sg child)      (values p lfun pc child last-catch srv))))  #| ; Not used anymore. Were they ever?; Binary search to get the inverse of error-frame-n.; Returns two values, the frame index and the child-frame.; The child-frame may be returned as NIL if it will cost almost as much as; calling error-frame-n to compute it.; Remember: (< (ccl::parent-frame f) f) is not necessarily true; Remember: stop assuming that it is, wherever that's happening.(defun error-frame-index (error-frame frame)  (let* ((addresses (addresses error-frame))         (sg (stack-group error-frame))         (count (frame-count error-frame))         (period (sampling-period error-frame))         (min-idx 1)         (max-idx (1+ (floor (1- count) period)))         (top (%sv.frame (svref addresses min-idx)))         (bottom (%sv.frame (svref addresses max-idx))))    (declare (fixnum min-idx max-idx))    (cond ((eql frame top) 0)          ((eql frame bottom) (* period (1- max-idx)))          ((not (< bottom frame top)) nil)          (t (loop               (let* ((mid-idx (ash (the fixnum (+ min-idx max-idx)) -1))                      (mid (%sv.frame (svref addresses mid-idx))))                 (declare (fixnum mid-idx))                 (if (eq mid-idx min-idx)                   (let ((res (* period (1- mid-idx)))                         (child nil))                     (loop                       (setq child mid mid (ccl::parent-frame mid sg))                       (incf res)                       (if (<= mid frame)                         (return-from error-frame-index                           (and (= mid frame) (values res child))))))                   (cond ((= mid frame) (return (* period (1- mid-idx))))                         ((< frame mid)                          (setq min-idx mid-idx))                         (t (setq max-idx mid-idx))))))))))(defun error-frame-child (error-frame frame)  (multiple-value-bind (index child) (error-frame-index error-frame frame)    (or child        (cond ((eql 0 index) (%sv.frame (svref (addresses error-frame) 0)))              ((and index (> index 0))               (values (error-frame-n error-frame (1- index))))              (t (ccl::child-frame frame (stack-group (inspector-object error-frame))))))))|#  ; end of "not used anymore"      (defmethod print-object ((f error-frame) stream)  (print-unreadable-object (f stream :type 'frame-ptr)    (print-error-frame-limits f stream)))(defun print-error-frame-limits (f stream)  (format stream "#x~x - #x~x" (stack-start f) (stack-end f)));;;;;;;;;;; The inspector for error-frame objects;;; True to show more info about backtrace frames(defvar *show-backtrace-frame-addresses* nil)(defclass stack-inspector (inspector)  ((show-frame-addresses :initform *show-backtrace-frame-addresses*                         :accessor show-frame-addresses)))(defmethod initialize-instance ((i stack-inspector) &rest initargs &key info)  (declare (dynamic-extent initargs))  (let* ((sg (ccl::bt.sg info))         (start (ccl::child-frame (ccl::parent-frame (ccl::bt.youngest info) sg) sg))         (end (ccl::child-frame (ccl::parent-frame (ccl::bt.oldest info) sg) sg)))    (apply #'call-next-method i           :object            (make-instance 'error-frame             :stack-start start             :stack-end end             :stack-group sg)           initargs)))(defmethod print-object ((i stack-inspector) stream)  (print-unreadable-object (i stream :type 'stack-inspector)    (print-error-frame-limits (inspector-object i) stream)))(defmethod addresses ((f stack-inspector))  (addresses (inspector-object f)))(defmethod error-frame-address-n ((f stack-inspector) n)  (error-frame-address-n (inspector-object f) n))(defmethod error-frame-regs-n ((f stack-inspector) n)  (error-frame-regs-n (inspector-object f) n))(defmethod compute-line-count ((f stack-inspector))  (setf (show-frame-addresses f) *show-backtrace-frame-addresses*)  (frame-count (inspector-object f)))(defmethod line-n ((f stack-inspector) n)  (multiple-value-bind (p lfun) (error-frame-address-n (inspector-object f) n)    (values lfun             (if (show-frame-addresses f) p n)            (if lfun :static '(:comment (:bold) (:plain :italic))) 'prin1-colon-line)))(defmethod prin1-label ((i stack-inspector) stream value &optional label type)  (declare (ignore value type))  (if (show-frame-addresses i)    (format stream "#x~x/#x~x"            (ccl::index->address label) (ccl::index->address (ccl::%frame-savevsp label)))    (call-next-method)))(defmethod prin1-value ((i stack-inspector) stream value &optional label type)  (declare (ignore label type))  (if value    (ccl::%lfun-name-string value stream)    (write-string "kernel" stream)))(defmethod line-n-inspector ((f stack-inspector) n value label type)  (declare (ignore value label type))  (multiple-value-bind (p lfun pc) (error-frame-address-n (inspector-object f) n)    (declare (ignore p))    (make-instance (inspector-class lfun) :object lfun :pc pc)));; inspecting a single stack frame;; The inspector-object is expected to be an error-frame(defclass stack-frame-inspector (inspector)  ((frame-number :initarg :frame-number :initform nil :reader frame-number)   (frame-info :accessor frame-info)   (label-columns :accessor label-columns)   (saved-register-count :accessor saved-register-count)))(defmethod initialize-instance ((i stack-frame-inspector) &rest initargs &key                                object frame-number)  (declare (dynamic-extent initargs))  (setq object (require-type object 'error-frame))  (apply #'call-next-method i          :object object         initargs)  (setf (frame-number i) frame-number))(defun integer-digits (integer &optional (base 10))  (setq integer (require-type integer 'fixnum))  (do ((digits (if (< integer 0) 2 1) (1+ digits))       (n (abs integer) (floor n base)))      ((if (< n base) (return digits)))))    (defmethod compute-line-count ((i stack-frame-inspector))  (let ((frame-number (frame-number i)))    (if (null frame-number)      0      (let* ((error-frame (inspector-object i))             (frame-info (multiple-value-list                           (error-frame-regs-n error-frame frame-number))))        (setf (frame-info i) frame-info)        (let ((count (ccl::count-values-in-frame                      (car frame-info)          ; this frame                      (stack-group error-frame)                      (cadddr frame-info))))    ; child frame          (setf (label-columns i) (integer-digits count))          (let ((lfun (cadr frame-info))                (pc (caddr frame-info)))            (declare (ignore p))            (+ count (setf (saved-register-count i)                           (logcount (or (ccl::registers-used-by lfun pc) 0))))))))))(defmethod line-n ((i stack-frame-inspector) n)  (unless (< -1 n (inspector-line-count i))    (line-n-out-of-range i n))  (let ((frame-info (frame-info i))        (saved-register-count (saved-register-count i)))    (if (< n saved-register-count)      (multiple-value-bind (mask regs) (apply #'ccl::saved-register-values (cdr frame-info))        (let* ((srv (nth 5 frame-info))               (unresolved (ccl::srv.unresolved srv))               (j ccl::*saved-register-count*)               (i n))          (loop            (loop (if (logbitp (decf j) mask) (return)))            (if (< (decf i) 0) (return)))          (let ((name (saved-register-name                       (elt ccl::*saved-register-numbers* (- ccl::*saved-register-count* 1 j)) (cadr frame-info) (caddr frame-info))))            (values (if (setq unresolved (logbitp j unresolved))                      *unbound-marker*                      (ccl::srv.register-n regs (- ccl::*saved-register-count* 1 j)))                    (cons n                          (cons (elt ccl::*saved-register-names* j) name))                    (if unresolved :static :normal)))))      (destructuring-bind (p lfun pc child &rest rest) frame-info        (declare (ignore rest))        (let ((offset (- n saved-register-count)))          (multiple-value-bind (var type name)                               (ccl::nth-value-in-frame p offset (stack-group (inspector-object i)) lfun pc child)            (values var (cons n (cons type name)) :normal)))))))(defmethod (setf line-n) (value (i stack-frame-inspector) n)  (unless (< -1 n (inspector-line-count i))    (line-n-out-of-range i n))  (let ((frame-info (frame-info i))        (saved-register-count (saved-register-count i)))    (if (< n saved-register-count)      (let* ((mask (apply #'ccl::saved-register-values (cdr frame-info)))             (srv (nth 5 frame-info))             (unresolved (ccl::srv.unresolved srv))             (j ccl::*saved-register-count*)             (i n))        (loop          (loop (if (logbitp (decf j) mask) (return)))          (if (< (decf i) 0) (return)))        (if (logbitp j unresolved) (line-n-out-of-range i n))        (apply #'ccl::set-saved-register value (- ccl::*saved-register-count* 1 j) (cdr frame-info)))      (destructuring-bind (p lfun pc child &rest rest) frame-info        (declare (ignore lfun pc rest))        (let ((offset (- n saved-register-count))              (sg (stack-group (inspector-object i))))          (ccl::set-nth-value-in-frame p offset sg value child))))))(defun saved-register-name (reg lfun pc)  (let* ((map (ccl::function-symbol-map lfun))         (names (car map))         (info (cdr map))         (j 0))    (dotimes (i (length names))      (when (and (eq reg (aref info j))                 (<= (aref info (1+ j)) pc (aref info (+ j 2))))        (return (aref names i)))      (incf j 3))))        (defmethod prin1-label ((i stack-frame-inspector) stream value &optional label type)  (declare (ignore value type))  (format stream "~vd: " (label-columns i) (car label)))(defmethod prin1-value ((i stack-frame-inspector) stream value &optional label type)  (declare (ignore type))  (destructuring-bind (n type . name) label    (declare (ignore n))    (if name (format stream "~s " name))    (if type (format stream "(~a) " type))    (if (eq value *unbound-marker*)      (format stream "??")      (prin1 value stream))))(defmethod (setf frame-number) (frame-number (i stack-frame-inspector))  (let ((max (1- (frame-count (inspector-object i)))))    (unless (or (null frame-number)                (and (<= 0 frame-number max)))      (setq frame-number (require-type frame-number `(or null (integer 0 ,max))))))  (unless (eql frame-number (frame-number i))    (setf (slot-value i 'frame-number) frame-number)    (setf (inspector-line-count i) nil)    frame-number));;;;;;;;;;; The middle pane => moves to bottom;;(defclass backtrace-info-pane (view)  ((stack-frame-inspector :initarg :stack-frame-inspector :accessor stack-frame-inspector)   (label-dialog-items :accessor label-dialog-items)   (value-dialog-items :accessor value-dialog-items)))(defmethod initialize-instance ((view backtrace-info-pane) &key)  (call-next-method)  (let ((bfont '("monaco" 9 :bold)) font)    (setf (label-dialog-items view)          (list (make-instance 'static-text-dialog-item                               :dialog-item-text "Size:"                               :view-font bfont                               :view-container view                               :help-spec 14073)                (make-instance 'static-text-dialog-item                               :dialog-item-text "PC:"                               :view-font bfont                               :view-container view                               :help-spec 14075)                (make-instance 'static-text-dialog-item                               :dialog-item-text "Address:"                               :view-font bfont                               :view-container view                               :help-spec 14074)))    (setf (value-dialog-items view)          (list (make-instance 'static-text-dialog-item                               :dialog-item-text ""                               :view-nick-name 'frame-size                               :view-font font                               :view-container view                               :help-spec 14073)                (make-instance 'static-text-dialog-item                               :dialog-item-text ""                               :view-nick-name 'program-counter                               :view-font font                               :view-container view                               :help-spec 14075)                (make-instance 'static-text-dialog-item                               :dialog-item-text ""                               :view-nick-name 'frame-address                               :view-font font                               :view-container view                               :help-spec 14074)))))(defclass backtrace-command-pane (command-pane-mixin bottom-line-mixin ccl::theme-background-view)  ())(defmethod initialize-instance ((view backtrace-command-pane) &key)  (call-next-method)  (add-subviews view                (make-instance                  'ccl::3d-button ;button-dialog-item                  ;:view-size button-size                  :view-nick-name 'Edit-button                  :dialog-item-text "Edit Value"                  :view-font '("Courier" 12 :bold)                  ;:view-position #@(100 0)                  ;:border-p nil                  :dialog-item-enabled-p nil                  :frame-p t                  :dialog-item-action                  #'(lambda (item)                      (edit-selection                       (inspector-view                        (view-named 'stack-frame-pane (view-window item)))))                  :help-spec 14084))  (let ((command-menu (make-instance 'pull-down-menu                        :update-function 'update-backtrace-command-menu                        :item-display "Commands"                        :crescent t                        :view-size nil                        :view-position #@(1 1)                        :auto-update-default nil                        ;:justify :right                        :view-nick-name 'menu                        :view-font '("Courier" 12 :bold)                        :view-container view                        :help-spec 14076)))    ;(setf (command-menu (view-container view)) command-menu)    (add-new-item command-menu                  "Edit Definition"                  #'(lambda ()                      (edit-stack-definition                       (inspector-view                        (view-named 'stack-pane (view-window command-menu)))))                  :help-spec 14081)    (add-new-item command-menu                  "Inspect Function"                  #'(lambda ()                      (inspect-selection                       (inspector-view (view-named 'stack-pane (view-window command-menu)))))                  :help-spec 14082)    (add-new-item command-menu                   "Return from frameÉ"                  #'(lambda () (backtrace-return-from-frame (view-window command-menu)))                  :help-spec '(14078 1 2))    (add-new-item command-menu                   "Restart frameÉ"                  #'(lambda () (backtrace-restart-frame (view-window command-menu)))                  :help-spec '(14079 1 2))    (add-new-item command-menu                  "RestartsÉ"                   #'(lambda () (backtrace-choose-restart (view-window command-menu)))                  :help-spec 14080)    (add-new-item command-menu                  "-"                  nil                  :disabled t)    (add-new-item command-menu                  "Edit ValueÉ"                  #'(lambda ()                      (edit-selection                       (inspector-view                        (view-named 'stack-frame-pane (view-window command-menu)))))                  :help-spec '(14077 1 2))    (add-new-item command-menu                  "Inspect Value"                  #'(lambda ()                      (inspect-selection                       (inspector-view (view-named 'stack-frame-pane (view-window command-menu)))))                  :help-spec 14083)    (add-new-item command-menu                  "-"                  nil                  :disabled t)    (add-new-item command-menu                  "Inspect break condition"                  #'(lambda ()                      (inspect                       (break-condition                        (inspector-object                         (find-named-sibling view 'stack-pane))))))    (flet ((stack-pane-inspector-view (command-view)             (inspector-view (find-named-sibling command-view 'stack-pane))))      (let (item)        (setq item              (add-new-item command-menu                            "Show all frames"                            #'(lambda ()                                (switch-show-all-frames (stack-pane-inspector-view view)))                            :update-function                            #'(lambda ()                                (update-show-all-frames item (stack-pane-inspector-view view))))))      (let (item)        (setq item              (add-new-item command-menu                            "Default show all frames"                            #'(lambda ()                                (switch-default-show-all-frames (inspector-view (find-named-sibling view 'stack-pane))))                            :update-function                            #'(lambda ()                                (update-default-show-all-frames item))))))))(defun backtrace-choose-restart (w)  (let ((p (ccl::stack-group-process            (stack-group             (inspector-object              (inspector (view-named 'stack-frame-pane w)))))))    (if p      (process-interrupt p                         #'ccl::choose-restart)      (ed-beep))))(defmethod edit-stack-definition ((view inspector-view))  (let ((selection (selection view)))    (when selection      (let* ((thing (cached-line-n view selection))             (real-thing (ccl::find-unencapsulated-definition thing)))        (when (edit-definition-p real-thing)          (edit-definition real-thing))))))(defmethod update ((pane backtrace-command-pane) &optional (window (view-window pane)))  (let* ((item (view-named 'edit-button pane)))    (when item      (set-dialog-item-enabled-p item (edit-value-ok window))))); These assume that *backtrace-internal-functions* is never null.(defun switch-show-all-frames (stack-view)  (let* ((error-frame (inspector-object stack-view))         (ignored-functions (ignored-functions error-frame)))    (setf (ignored-functions error-frame)          (if (null ignored-functions) *backtrace-internal-functions* nil))    (resample-stack-view stack-view)))(defun resample-stack-view (view)  (initialize-addresses (inspector-object view))  (set-start-line view 0)  (set-selection view nil)  (resample view)  (install-selection view))(defun update-show-all-frames (menu-item stack-view)  (let ((ignored-functions (ignored-functions (inspector-object stack-view))))    (set-menu-item-title  menu-item                          (if ignored-functions                            "Show all frames"                            "Hide internal frames"))))(defun update-default-show-all-frames (menu-item)  (set-menu-item-title menu-item                       (if *backtrace-hide-internal-functions-p*                         "Default show all frames"                         "Default hide internal frames")))(defun switch-default-show-all-frames (stack-view)  (setq *backtrace-hide-internal-functions-p* (not *backtrace-hide-internal-functions-p*))  (unless (eq (not (null *backtrace-hide-internal-functions-p*))              (not (null (ignored-functions (inspector-object stack-view)))))    (switch-show-all-frames stack-view)))(defun update-backtrace-command-menu (menu)  (let* ((window (view-window menu))         (view (inspector-view (view-named 'stack-frame-pane window)))         (selection (selection view))         (i (inspector view))         (sg (stack-group (inspector-object i)))         (info (and (frame-number i) (frame-info i)))         (enabled (and info                       ; The third value is an unresolved saved variable mask.                       ; If it is zero, we know all the saved var values, so the frame can be restarted.                       (let ((srv (nth-value 2 (apply #'ccl::parent-frame-saved-vars sg (cdddr info)))))                         (and srv (eql 0 (ccl::srv.unresolved srv)))))))    (set-menu-item-enabled-p (find-menu-item menu "Return from frameÉ") enabled)    (set-menu-item-enabled-p (find-menu-item menu "Restart FrameÉ") enabled)    (set-menu-item-enabled-p      (find-menu-item menu "Edit ValueÉ")     (edit-value-ok window))     (set-menu-item-enabled-p (find-menu-item menu "Inspect Value") selection)    (let* ((stack (inspector-view (view-named 'stack-pane window)))           (selection (selection stack)))      (set-menu-item-enabled-p       (find-menu-item menu "Edit Definition")       (and selection (edit-definition-p (ccl::find-unencapsulated-definition (cached-line-n stack selection)))))      (set-menu-item-enabled-p (find-menu-item menu "Inspect Function") selection)))  (dolist (item (menu-items menu))    (let ((f (menu-item-update-function item)))      (when f (funcall f)))))                     (defmethod adjust-subview-positions ((view backtrace-info-pane))  (let* ((h 6)          (labels (label-dialog-items view))         (value-width (+ 6 (string-width "#xFFFFFFFF" (view-font (car labels))))))    (do ((labs labels (cdr labs))         (vals (value-dialog-items view) (cdr vals)))        ((null labs))      (let ((lab (car labs))            (val (car vals)))        (let ((size (view-default-size lab)))          (set-view-size lab size)          (set-view-position lab h 4)          (setq h (+ h (point-h size) ))          (set-view-position val h 4)          (set-view-size val value-width (point-v size))          (setq h (+ h value-width )))))      (set-view-size view                      (- (point-h (view-size (view-container view))) 17)                     (point-v (view-size view)))))(defmethod update ((view backtrace-info-pane) &optional window)  (declare (ignore window))  (let* ((i (stack-frame-inspector view))         frame-size frame-address pc)    (when (frame-number i)      (let ((frame-info (frame-info i)))        (setq frame-size (- (inspector-line-count i) (saved-register-count i))              frame-address (ccl::index->address (car frame-info))              pc (caddr frame-info))))    (set-dialog-item-text (view-named 'frame-size view)                          (if frame-size (format nil "~d value~:p" frame-size) ""))    (set-dialog-item-text (view-named 'frame-address view)                          (if frame-address (format nil "#x~x" frame-address) ""))    (set-dialog-item-text (view-named 'program-counter view)                          (if pc (format nil "~d" pc) ""))));;;;;;;;;;; A view to display the stack backtrace;;(defclass stack-inspector-view (inspector-view) ())(defmethod view-click-event-handler ((view stack-inspector-view) where)  (declare (ignore where))  (call-next-method)  (install-selection view))(defmethod install-selection ((view stack-inspector-view))  (let* ((selection (selection view))         (window (view-container (view-container view)))         (info-pane (view-named 'info-pane window))         (stack-frame-pane (view-named 'stack-frame-pane window))         (stack-frame-view (inspector-view stack-frame-pane))         (stack-frame-inspector (inspector stack-frame-view)))    (unless (eql selection (frame-number stack-frame-inspector))      (setf (frame-number stack-frame-inspector) selection)      (set-start-line stack-frame-view 0)      (set-selection stack-frame-view nil)      (setf (the-undo-selection window) nil)    ; can't undo no more no more      (resample stack-frame-pane)      (update info-pane)))  view)(defclass backtrace-inspector-pane (inspector-pane) ())(defmethod print-object ((view backtrace-inspector-pane) stream)  (print-unreadable-object (view stream :type 'backtrace-inspector-pane :identity t)    (let ((nick-name (view-nick-name view)))      (when nick-name (prin1 nick-name stream)))))(defmethod replace-object-p ((view backtrace-inspector-pane))  nil)(defclass backtrace-view (view)  ((info :initarg :info :accessor info)))(defclass dragging-pane-splitter (pane-splitter) ())(defmethod view-cursor ((p dragging-pane-splitter) where)  (declare (ignore where))  ccl::*vertical-ps-cursor*)(defmethod view-draw-contents ((p dragging-pane-splitter))  (when t ;(window-active-p (view-window p))    (with-focused-view p      (with-back-color ccl::*lighter-gray-color*        (let ((size (view-size p)))          (rlet ((rect :rect                       :topleft #@(0 0)                       :bottomright size))            (#_eraserect rect))          (with-fore-color (if (window-active-p (view-window p)) *black-color* *gray-color*)            (let ((v (point-v size)))              (case (pane-splitter-position (scroll-bar p))                (:bottom                 (#_moveto 0 0)                 (#_line 0 v)                 (#_moveto 5 5)                 (#_line 6 0)                 (#_line -3 -3)                 (#_line -2 2)                 (#_line 3 0)                 (#_line -1 -1))                         (t (#_moveto 0 0)                   (#_line 0 v)                   (#_moveto  5 1)                   (#_line 6 0)                   (#_line -3 3)                   (#_line -2 -2)                   (#_line 3 0)                   (#_line -1 1))))))))))(defmethod initialize-instance ((view backtrace-view) &rest initargs &key                                 view-container info (top-pane-size #@(100 82)))  (declare (dynamic-extent initargs))  (apply #'call-next-method view :view-container nil initargs)  (let* ((command-pane (make-instance 'backtrace-command-pane                         :view-nick-name 'command-pane                         ;:view-size #@(100 17)                         :view-container view))         (stack-inspector (make-instance 'stack-inspector :info info))         (error-frame (inspector-object stack-inspector))         (stack-frame-pane (make-instance 'backtrace-inspector-pane                                          :inspector (make-instance 'stack-frame-inspector                                                                    :object error-frame)                                          :pane-splitter :top                                          :pane-splitter-cursor *arrow-cursor*                                          :pane-splitter-class 'dragging-pane-splitter                                          :grow-box-p nil                                          :view-nick-name 'stack-frame-pane                                          :view-container view                                          :help-spec 14072)))        (set-view-size command-pane 100 (point-v (view-size (view-named 'menu command-pane))))    (make-instance 'backtrace-inspector-pane      :inspector stack-inspector      :inspector-view-class 'stack-inspector-view      :pane-splitter :bottom      :double-bottom-line t      :pane-splitter-class 'dragging-pane-splitter      :pane-splitter-cursor *arrow-cursor*      :pane-splitter-length 8      :view-size top-pane-size      :view-nick-name 'stack-pane      :view-container view      :cache-p (< (frame-count error-frame) 5000)      :help-spec 14071)    (make-instance 'backtrace-info-pane                   :stack-frame-inspector (inspector stack-frame-pane)                   :view-nick-name 'info-pane                   :view-container view                   :view-size (make-point (point-h top-pane-size) 17)                   :help-spec 14070)    (when view-container      (set-view-container view view-container)))); Keep the dialog designer off my backtrace windows.(defmethod ccl::editing-dialogs-p ((view backtrace-view))  nil); The 1- here and the 1+ in split-pane are because the line seperating the; top pane from the command pane is inside of the top pane; (trust me, I got the fencepost right this time)(defmethod pane-splitter-outline-position ((view backtrace-inspector-pane)                                           scroll-bar mouse-pos)  (declare (ignore  mouse-pos))  (case (pane-splitter-position scroll-bar)    (:bottom (subtract-points  (view-size view) #@(1 1)))    (t #@(0 0))))(defmethod pane-splitter-corners ((view backtrace-inspector-pane) scroll-bar)  (declare (ignore scroll-bar))  (view-corners (view-window view)))(defmethod split-pane ((pane backtrace-inspector-pane) scroll-bar pos direction flag)  (declare (ignore direction))  (let* ((view (view-container pane))         (info-pane (view-named 'info-pane view)))    (when (eq (pane-splitter-position scroll-bar) :top)      (setq pane (view-named 'stack-pane view))      (setq pos (+ pos (point-v (view-size pane)) -1)))    (when flag      (setq pos (max 56                     (min (1+ pos) (- (point-v (view-size view))                                       (point-v (view-size info-pane))                                      67))))      (set-view-size pane (point-h (view-size pane)) pos)      (adjust-subview-positions view)      (when (typep view 'backtrace-window)        (update-*backtrace-sizes* view)))))(defmethod initialize-instance :after ((pane backtrace-inspector-pane) &key double-bottom-line)  (when double-bottom-line    (make-instance 'double-bottom-line      :view-size (make-point (point-h (view-size pane)) 3)      :view-position (make-point 0 (- (point-v (view-size pane)) 3))      :view-nick-name 'double-bottom-line      :view-container pane)))#|(defmethod (setf wptr) (wptr (view backtrace-view))  (call-next-method)  (when wptr    (adjust-subview-positions view)))|#(defmethod install-view-in-window ((view backtrace-view) window)  (declare (ignore window))  (call-next-method)  (adjust-subview-positions view))(defmethod adjust-subview-positions ((view backtrace-view))  (let* ((size (view-size view))         (width (point-h size))         (height (point-v size))         (command-pane (view-named 'command-pane view))   ; height unchanged top         (stack-pane (view-named 'stack-pane view))  ; height unchanged second         (info-pane (view-named 'info-pane view))  ; height unchanged bottom                  (stack-frame-pane (view-named 'stack-frame-pane view))         info-pane-height h v)    (when (and stack-pane info-pane stack-frame-pane command-pane)   ; NIL on initialize-instance of backtrace-window      (setq h (point-h (view-position command-pane)))      (adjust-subview-positions info-pane)      (setq info-pane-height (point-v (view-size info-pane)))      (setq v (+ (point-v (view-size command-pane))                 (point-v (view-size stack-pane))))      (set-view-size command-pane width (point-v (view-size command-pane)))      ;(adjust-subview-positions command-pane)      (set-view-position stack-pane h (point-v (view-size command-pane)))      (set-view-size stack-pane width (point-v (view-size stack-pane)))      (set-view-position stack-frame-pane h  v)      (set-view-size stack-frame-pane width (- height v info-pane-height -3))      (set-view-position info-pane h (- height info-pane-height))      (set-view-size info-pane (- width 17) (point-v (view-size info-pane))))))#|(defmethod adjust-subview-positions ((pane backtrace-command-pane))  (let* ((size (view-size pane))         (menu (view-named 'menu pane))         (width (point-h size)))    (set-view-position menu (1+ (- width (point-h (view-size menu)))) (point-v (view-position menu)))))|#(defmethod set-view-size ((view backtrace-view) h &optional v)  (declare (ignore h v))  (prog1 (call-next-method)    (adjust-subview-positions view))); view-size, view-position, and view-size of the top-pane(defparameter *backtrace-sizes* '(#@(300 249) (:top 75) #@(100 82)))(defclass backtrace-window (undo-view-mixin backtrace-view window) ()  (:default-initargs    :view-size (car *backtrace-sizes*)    :view-position (cadr *backtrace-sizes*)    :top-pane-size (caddr *backtrace-sizes*)    :window-title "Backtrace"))(defmethod ccl::editing-dialogs-p ((view backtrace-window))  nil)(defmethod initialize-instance ((view backtrace-window) &rest initargs &key                                 info (window-show t))  (declare (dynamic-extent initargs))  (apply #'call-next-method view :window-show nil initargs)  (adjust-subview-positions view)  (setf (ccl::bt.dialog info) view)  ; All this work to tile the window.  (let* ((pos nil)         (temp #'(lambda (w)                   (let ((w-pos (view-position w)))                       (if pos                         (setq pos (make-point (max (point-h pos) (point-h w-pos))                                               (max (point-v pos) (point-v w-pos))))                         (setq pos w-pos))))))    (declare (dynamic-extent temp))    (map-windows temp :class 'backtrace-window)    (when pos      (let ((old-pos (view-position view)))        (set-view-position view                           (+ (point-h pos) *window-tiling-offset-h*)                           (+ (point-v pos) *window-tiling-offset-v*))        (window-ensure-on-screen view old-pos (view-size view)))))  (when window-show    (window-select view)))(defun update-*backtrace-sizes* (window)  (setf (car *backtrace-sizes*) (view-size window)        (cadr *backtrace-sizes*) (view-position window)        (caddr *backtrace-sizes*) (view-size (view-named 'stack-pane window))))(defmethod set-view-size ((view backtrace-window) h &optional v)  (declare (ignore h v))  (prog1    (call-next-method)    (update-*backtrace-sizes* view)))(defmethod set-view-position ((view backtrace-window) h &optional v)  (declare (ignore h v))  (prog1    (call-next-method)    (update-*backtrace-sizes* view)))(defmethod window-close :before ((view backtrace-window))  (init-inspector-history)  (setf (ccl::bt.dialog (info view)) nil))(defmethod set-view-font ((view backtrace-window) font-spec)  (declare (ignore font-spec))  (call-next-method)  (when (adjust-subview-positions view)   ; startup glitch    (resample (view-named 'stack-pane view))    (resample (view-named 'stack-frame-pane view))    (invalidate-view view)))(defmethod window-zoom-event-handler ((view backtrace-window) msgw)  (declare (ignore msgw))  (call-next-method)  (adjust-subview-positions view))(defmethod copy ((view backtrace-window))  (copy (inspector-view (view-named 'stack-frame-pane view))))(defmethod edit-value-ok ((window backtrace-window))  (let* ((view (inspector-view (view-named 'stack-frame-pane window)))         (selection (selection view)))    (and selection         (multiple-value-bind (value comment type) (cached-line-n view selection)           (declare (ignore value comment))           (neq type :static)))))(defmethod paste ((view backtrace-window))  ; Can't paste yet.  (paste (inspector-view (view-named 'stack-frame-pane view))))(defmethod ccl::window-can-do-operation ((view backtrace-window) op &optional item)  ;(declare (ignore item))  (case op    (undo     (view-can-undo-p (inspector-view (view-named 'stack-frame-pane view)) item))    (t (method-exists-p op view))))(defmethod undo ((view backtrace-window))  (undo (inspector-view (view-named 'stack-frame-pane view))));;;;;;;;;;; Interface to the break-loop;;(defun select-backtrace (&aux (info (car ccl::*backtrace-dialogs*)))    (unless info (error "No context for backtrace"))    (if (ccl::bt.dialog info)      (window-select (ccl::bt.dialog info))      (make-instance 'backtrace-window :info info                     :window-title (format nil "Backtrace for ~A"                                           (process-name                                            (ccl::stack-group-process                                             (ccl::bt.sg info)))))));; Interface to apply-in-nth-frame(defmethod ccl::nth-frame ((w backtrace-window) target n)  (let ((error-frame (inspector-object (view-named 'stack-pane w))))    (unless (eql target (stack-start error-frame))      (error "Inconsistent args to nth-frame"))    (error-frame-n error-frame n)));;;;;;;;;;; Interface to LOCAL;;(defun ccl::names-in-frame (&optional (window (front-window :class 'backtrace-window)))  (when window    (let* ((view (inspector-view (view-named 'stack-frame-pane window)))           (inspector (inspector view))           (lines (inspector-line-count inspector))           res)      (dotimes (i lines)        (multiple-value-bind (val label) (cached-line-n view i)          (declare (ignore val))          (push (cddr label) res)))      (nreverse res))))(defun ccl::nth-frame-info (n &optional (window (front-window :class 'backtrace-window)))  (when window    (let* ((view (inspector-view (view-named 'stack-frame-pane window))))      (values (cached-line-n view n)))))(defun ccl::set-nth-frame-value (n new-value)  (let ((window (front-window :class 'backtrace-window)))    (let* ((view (inspector-view (view-named 'stack-frame-pane window)))           (inspector (inspector view)))      (setf (line-n inspector n) new-value)      (resample view)))  new-value)(defun ccl::frame-lfun (&optional (window (front-window :class 'backtrace-window)))  (when window    (let* ((inspector (inspector (view-named 'stack-frame-pane window)))           (info (frame-info inspector)))      (when info        (values (cadr info) (caddr info)))))); Old inspector function that some folks were used to(defun ccl::top-inspect-form ()  (let ((w (front-window :class 'inspector-window)))    (and w (inspector-object w))));;;;;;;;;;; return-from and restart frame;;#| ; No longer used; gets the most recent values for saved registers between frame and last-catch-since frame; the info may already be in backtrace info but this is easier than figuring out where it is.(defun merge-saved-vars (sg frame &optional (srv (ccl::%cons-saved-register-vector)))  (let* (#-ppc-target         (sgbuf (ccl::sg-buffer sg))         (csbuf #-ppc-target (ccl::sgbuf.csbuf sgbuf)                #+ppc-target nil)         last-catch)    (ccl::my-saved-vars sg frame srv)    (setq last-catch (ccl::last-catch-since frame sg))    (loop      (dotimes (i ccl::*saved-register-count*                  (return))             ; quit if got all        (when (null (ccl::srv.register-n srv i))          (return)))      (let ((child (ccl::child-frame frame sg)))        (when (or (null child) (ccl::%stack< child (ccl::catch-frame-sp last-catch) csbuf))          (return))        (let ((srv-2 (ccl::%cons-saved-register-vector)))          (declare (dynamic-extent srv-2))          (ccl::my-saved-vars sg child srv-2)          (dotimes (i ccl::*saved-register-count*)            (when (null (ccl::srv.register-n srv i))              (setf (ccl::srv.register-n srv i) (ccl::srv.register-n srv-2 i)))))        (setq frame child)))      srv))|#                           (defun backtrace-return-from-frame (w)  (setq w (require-type w 'backtrace-window))  (let* ((i (inspector (view-named 'stack-frame-pane w)))         (info (frame-info i))         (sg (stack-group (inspector-object i)))         (frame (car info))         (srv (ccl::frame-restartable-p frame sg)))    (if (not srv)      (ed-beep)                   ; Paranoia is a wonderful thing      (multiple-value-bind (value ok-button-p) (edit-value nil nil)        (when ok-button-p          (ccl::apply-in-frame-internal            sg           frame           #'values           (if (and (consp value) (eq (car value) 'values)) (cdr value) (list value))           srv))))))(defun add-child-window (w child)  (view-put w :child-windows (push child (view-get w :child-windows))))(defun backtrace-restart-frame (w)  (setq w (require-type w 'backtrace-window))  (let* ((inspector (inspector (view-named 'stack-frame-pane w)))         (info (frame-info inspector))         (error-frame (inspector-object inspector))         (sg (stack-group error-frame)))    (destructuring-bind (frame lfun pc child &rest rest) info      (declare (ignore rest))      (multiple-value-bind (args types names count nclosed)                           (ccl::frame-supplied-args frame lfun pc child sg)        (let* ((frame (car info))               (srv (ccl::frame-restartable-p frame sg)))          (if (not (and (or (eq count t) (>= count nclosed)) frame srv))            (ed-beep)            (let* ((name (function-name lfun))                   (f (ignore-errors (fboundp name))))              (cond ((null f))                    ((eq (ccl::closure-function f) lfun)                     (setq lfun name                           args (nthcdr nclosed args)                           types (nthcdr nclosed types)                           names (nthcdr nclosed names)                           nclosed 0))                    (f (setq lfun name)))              (let ((i (make-instance 'function-args-inspector                         :stack-frame-inspector inspector                         :restart-srv srv                         :frame-to-restart frame                         :object (cons lfun args)                         :types types :names names :nclosed nclosed)))                (add-child-window w                                  (make-instance 'inspector-window                                    :inspector i :view-position '(:top 50)))))))))))(defclass function-args-inspector (inspector)  ((types :initarg :types :accessor types)   (names :initarg :names :accessor names)   (nclosed :initarg :nclosed :accessor nclosed)   (stack-frame-inspector :initarg :stack-frame-inspector :reader stack-frame-inspector)   (frame-to-restart :initarg :frame-to-restart :reader frame-to-restart)   (restart-srv :initarg :restart-srv :reader restart-srv)))(defmethod inspector-window-title ((i function-args-inspector))  (format nil "Restart frame at #x~x" (ccl::index->address (frame-to-restart i))))(defmethod compute-line-count ((i function-args-inspector))  (+ 3 (length (inspector-object i))))(defmethod line-n ((i function-args-inspector) n)  (let ((f&args (inspector-object i)))    (case n      (0 f&args)      (1 (values nil "Choose \"Restart\" from \"Commands\" menu when ready"                 :comment))      (2 (values (car f&args) "Function" :colon))      (3 (values (ignore-errors (arglist (car f&args))) "Arglist: " :static))      (t (decf n 4)         (let ((args (nthcdr n (cdr f&args)))               (type (nth n (types i)))               (name (nth n (names i))))           (unless args (line-n-out-of-range i (+ n 4)))           (values (car args) (list n type name)))))))(defmethod (setf line-n) (value (i function-args-inspector) n)  (flet ((install-new-function (i function)           (let ((arglist (arglist function))                 (types nil)                 (names nil)                 (type "required"))             (dolist (name arglist)               (cond ((eq name '&optional) (setq type "optional"))                     ((memq name lambda-list-keywords) (return))                     (t (push type types)                        (push name names))))             (setf (types i) types                   (names i) names)             (unless (eql 0 (nclosed i))               (let ((f&args (inspector-object i)))                 (setf (cdr f&args) (nthcdr (nclosed i) (cdr f&args))))               (setf (nclosed i) 0)))))    (case n      (0 (if (ignore-errors              (and (listp value) (length value) (or (functionp (car value))                                                     (fboundp (car value)))))           (progn             (setf (inspector-object i) value)             (install-new-function i (car value))             (resample-it))           (ed-beep)))      ((1 3) (setf-line-n-out-of-range i n))      (2 (if (ignore-errors (or (functionp value) (fboundp value)))           (progn             (setf (car (inspector-object i)) value)             (install-new-function i value)             (resample-it))           (ed-beep)))      (t (decf n 4)         (let ((args (nthcdr n (cdr (inspector-object i)))))           (unless args (setf-line-n-out-of-range i (+ n 4)))           (setf (car args) value)           (resample-it))))))(defmethod prin1-label ((i function-args-inspector) stream value &optional label type)  (declare (ignore value type))  (if (consp label)    (format stream "~d: " (car label))    (call-next-method)))(defmethod prin1-value ((i function-args-inspector) stream value &optional label type)  (declare (ignore type))  (if (consp label)    (destructuring-bind (n type name) label      (declare (ignore n))      (when name        (princ name stream)        (tyo #\space stream))      (when type        (format stream "(~a) " type))))  (prin1 value stream))(defmethod inspector-commands ((i function-args-inspector))  (let ((res          `(("Restart "            ,#'(lambda ()                 (window-close (view-window (inspector-view i)))                 (let* ((stack-frame-inspector (stack-frame-inspector i)))                   (if (wptr (inspector-view stack-frame-inspector))                     (let* ((frame (frame-to-restart i))                            (srv (restart-srv i))                            (f&args (inspector-object i))                            (sg (stack-group (inspector-object stack-frame-inspector))))                       (ccl::apply-in-frame-internal                        sg                        frame                        (car f&args)  ; fn                        (cdr f&args)  ; args                        srv)))))))))      ; saved registers    (let* ((view (inspector-view i))           (selection (selection view)))      (let ((f&args (inspector-object i)))        (push `("Insert arg after selection"                ,(and selection (>= (decf selection 3) 0)                      #'(lambda ()                          (push nil (cdr (nthcdr selection f&args)))                          (resample-it))))              res)        (push `("Delete (and Copy) selected arg"                ,(and selection (> selection 0)                      #'(lambda ()                          (copy view)                          (pop (nthcdr selection f&args))                          (if (>= selection (length f&args))                            (set-selection (inspector-view i) nil))                          (resample-it))))              res)))    (nreverse res)))              